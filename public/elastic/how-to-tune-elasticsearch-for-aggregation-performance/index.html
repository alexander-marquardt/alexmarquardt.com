<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>How to tune Elasticsearch for aggregation performance | Alexander Marquardt</title>
<meta name="keywords" content="">
<meta name="description" content="October 2, 2018
Introduction
By default, Elasticsearch is tuned for the best trade-off between write performance and query performance for the majority of use cases. In this blog posting we cover some parameters that can be configured to improve query-time aggregation performance, with some of these improvements coming at the expense of write performance. 
Note that this blog posting does not present anything that is not already documented in other locations. The goal here is to pull together relevant information into a small and digestible posting that provides a few pointers on how to improve slow Elasticsearch aggregations.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/elastic/how-to-tune-elasticsearch-for-aggregation-performance/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.c165320a1f0c5bf24696dd0ab01f4316681654fa067af428b14198e94a4423c2.css" integrity="sha256-wWUyCh8MW/JGlt0KsB9DFmgWVPoGevQosUGY6UpEI8I=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/elastic/how-to-tune-elasticsearch-for-aggregation-performance/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Alexander Marquardt (Alt + H)">
                <img src="http://localhost:1313/alexmarquardt-light.png" alt="" aria-label="logo"
                    height="96">Alexander Marquardt</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      How to tune Elasticsearch for aggregation performance
    </h1>
    <div class="post-meta"><span title='2018-10-02 00:00:00 +0000 UTC'>October 2, 2018</span>

</div>
  </header> 
  <div class="post-content"><p>October 2, 2018</p>
<h1 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h1>
<p>By default, Elasticsearch is tuned for the best trade-off between write performance and query performance for the majority of use cases. In this blog posting we cover some parameters that can be configured to improve query-time aggregation performance, with <em>some</em> of these improvements coming at <em>the expense of write performance.</em> </p>
<p>Note that this blog posting does not present anything that is not already documented in other locations. The goal here is to pull together relevant information into a small and digestible posting that provides a few pointers on how to improve slow Elasticsearch aggregations.</p>
<h1 id="a-description-of-the-refresh-interval">A description of the refresh interval<a hidden class="anchor" aria-hidden="true" href="#a-description-of-the-refresh-interval">#</a></h1>
<p>In this section we give an overview of the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/tune-for-indexing-speed.html#_increase_the_refresh_interval">refresh interval</a>, which is useful for understanding subsequent sections of this blog.</p>
<p>As documents are inserted into Elasticsearch, they are written into a buffer and then periodically flushed from that buffer into <a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/dynamic-indices.html#dynamic-indices">segments</a> when a <em>refresh</em> occurs. By default refreshes occur every 1 second, which is known as the refresh_interval. Newly inserted documents are not searchable until they have been flushed into segments.</p>
<p>In the background, small segments are merged into larger segments, and those larger segments are merged into even larger segments, and so on.  Therefore, by enabling frequent refreshes, Elasticsearch needs to do more background work merging small segments than it would need to do with less frequent refreshes which would create larger segments to start with.</p>
<p>While frequent refreshes are necessary if near-real-time search functionality is required for newly inserted data, they may not be necessary in other cases. If an application can wait longer for recent data to appear in search results, then the refresh interval should be increased in order to improve the efficiency of data ingestion, which in-turn should free up resources to help query performance.</p>
<h1 id="enable-eager-global-ordinals-to-improve-the-performance-of-high-cardinality-terms-aggregations">Enable eager global ordinals to improve the performance of high-cardinality terms aggregations<a hidden class="anchor" aria-hidden="true" href="#enable-eager-global-ordinals-to-improve-the-performance-of-high-cardinality-terms-aggregations">#</a></h1>
<p><strong>May 9, 2019 update</strong>: A more in-depth explanation of terms aggregations on high-cardinality fields has now been published: <a href="https://www.elastic.co/blog/improving-the-performance-of-high-cardinality-terms-aggregations-in-elasticsearch">https://www.elastic.co/blog/improving-the-performance-of-high-cardinality-terms-aggregations-in-elasticsearch</a>.</p>
<p>The performance of terms aggregations on high-cardinality fields (fields with thousands or millions of possible unique values) may become slow and unpredictable in-part because by default global ordinals are <em>lazily</em> built on the first aggregation that occurs since the previous refresh <a href="https://github.com/elastic/elasticsearch/issues/19780">as described here</a>.</p>
<p>Building <a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/eager-global-ordinals.html">global ordinals eagerly</a> should improve such aggregations and make response times more consistent, as the related data structure will be created when segments are refreshed, as opposed to the first query after each refresh.</p>
<p>Note that if global ordinals are eagerly built, this will impact write performance because new global ordinals will be created on every refresh. To minimize the additional workload caused by frequently building global ordinals due to frequent refreshes, increase the refresh interval.</p>
<h1 id="pre-sort-indexes-at-insertion-time">Pre-sort indexes at insertion time<a hidden class="anchor" aria-hidden="true" href="#pre-sort-indexes-at-insertion-time">#</a></h1>
<p><a href="https://www.elastic.co/blog/index-sorting-elasticsearch-6-0">Index sorting</a> can be used to pre-sort indices at insertion time as opposed to at query time, which should improve the performance of range queries and sort operations. Note that this will increase the cost of indexing documents into Elasticsearch.</p>
<h1 id="take-advantage-of-the-node-query-cache-cache-filter-results">Take advantage of the node query cache (cache filter results)<a hidden class="anchor" aria-hidden="true" href="#take-advantage-of-the-node-query-cache-cache-filter-results">#</a></h1>
<p>The <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-cache.html">Node query cache</a> can be used for efficiently caching results of <a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.4/query-filter-context.html">filter operations</a>. This is effective if the same filter is executed multiple times, but changing even a single value within the filter means that a new filter result will need to be computed.</p>
<p>For example, queries that use “<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html">now</a>” within the filter context cannot be cached since the value of now is constantly changing. Such requests can be made more cacheable by applying <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html#ranges-on-dates">datemath</a> on the now field to round it to the nearest minute/hour/etc, so that the filter results can be cached and re-used for queries that appear within the same interval that has been rounded to.</p>
<h1 id="general-elasticsearch-settings">General Elasticsearch settings<a hidden class="anchor" aria-hidden="true" href="#general-elasticsearch-settings">#</a></h1>
<p>Read the following official Elasticsearch documentation for more details on tuning an Elasticsearch cluster:</p>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.0/system-config.html">Important system configuration</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.0/tune-for-search-speed.html">Tune for search speed</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.0/tune-for-indexing-speed.html">Tune for indexing speed</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.0/tune-for-disk-usage.html">Tune for disk usage</a></li>
</ul>
<p>Additional information on tuning slow queries can be found in <a href="https://www.elastic.co/blog/advanced-tuning-finding-and-fixing-slow-elasticsearch-queries">this blog about advanced Elasticsearch tuning</a>.</p>
<p>In addition to the above, having too many shards is a common cause of performance problems. <a href="https://www.elastic.co/blog/how-many-shards-should-i-have-in-my-elasticsearch-cluster">This blog about sharding</a> gives good rules of thumb to follow.</p>
<p>The JVM heap size should generally be set to a maximum of 30GB. <a href="https://www.elastic.co/blog/a-heap-of-trouble">This blog</a> gives a good description of why setting this value higher than 30GB is generally undesirable.</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-configuration-memory.html">Swapping is bad for performance</a> and should be disabled.</p>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>In this blog post, we have covered a few strategies for improving the aggregation performance of your Elasticsearch cluster.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Alexander Marquardt</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>

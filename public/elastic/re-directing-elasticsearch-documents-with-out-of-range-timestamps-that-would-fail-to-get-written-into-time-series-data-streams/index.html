<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="light">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Re-directing Elasticsearch documents with out-of-range timestamps that (would) fail to get written into Time Series Data Streams | Alexander Marquardt</title>
<meta name="keywords" content="elasticsearch">
<meta name="description" content="Introduction
Elasticsearch Time Series Data Streams (TSDS) are designed to provide an efficient and scalable way to handle time-based data within the Elasticsearch ecosystem. This feature is specifically optimized for storing, searching, and managing time-series data such as metrics, and events, where data is continuously indexed in chronological order. However, if events arrive with timestamps that fall outside of a pre-defined range, they will be lost.
In this blog I will demonstrate logic that can be added to an Elasticsearch ingest pipeline which can be used to intercept documents that would be rejected by the TSDS index due to timestamp range issues, and to instead redirect them to a &ldquo;failed&rdquo; index. The documents that are redirected to the &ldquo;failed&rdquo; index may (for example) be used to raise alerts and examined.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/elastic/re-directing-elasticsearch-documents-with-out-of-range-timestamps-that-would-fail-to-get-written-into-time-series-data-streams/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2fe4dc5b52567b7454ee976e121c74370e14415db7564bb5ae6de9bd591821ff.css" integrity="sha256-L&#43;TcW1JWe3RU7pduEhx0Nw4UQV23Vku1rm3pvVkYIf8=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/elastic/re-directing-elasticsearch-documents-with-out-of-range-timestamps-that-would-fail-to-get-written-into-time-series-data-streams/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    }

</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Alexander Marquardt (Alt + H)">Alexander Marquardt</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Re-directing Elasticsearch documents with out-of-range timestamps that (would) fail to get written into Time Series Data Streams
    </h1>
    <div class="post-meta"><span title='2024-04-16 00:00:00 +0000 UTC'>April 16, 2024</span>&nbsp;·&nbsp;<span>4 min</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#motivation" aria-label="Motivation">Motivation</a></li>
                <li>
                    <a href="#design" aria-label="Design">Design</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>Elasticsearch <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/tsds.html">Time Series Data Streams (TSDS)</a> are designed to provide an efficient and scalable way to handle time-based data within the Elasticsearch ecosystem. This feature is specifically optimized for storing, searching, and managing time-series data such as metrics, and events, where data is continuously indexed in chronological order. However, if events arrive with timestamps that fall outside of a pre-defined range, they will be lost.</p>
<p>In this blog I will demonstrate logic that can be added to an Elasticsearch ingest pipeline which can be used to intercept documents that would be rejected by the TSDS index due to timestamp range issues, and to instead redirect them to a &ldquo;failed&rdquo; index. The documents that are redirected to the &ldquo;failed&rdquo; index may (for example) be used to raise alerts and examined.</p>
<h2 id="motivation">Motivation<a hidden class="anchor" aria-hidden="true" href="#motivation">#</a></h2>
<p>As discussed in a previous blog on <a href="https://alexmarquardt.com/2020/06/02/storing-ingest-time-and-calculating-ingest-lag-in-elasticsearch/">Storing ingest time and calculating ingest lag in Elasticsearch</a>, there are several reasons why events may have incorrect timestamps. If such events are to be sent into a TSDS, they may be rejected due to falling outside of the range that is allowed by the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/tsds-index-settings.html">look_back_time or the look_ahead time</a>. Additionally, if ILM is used then older indices may already be set to read-only, which may cause events with old timestamps to silently fail to be written.</p>
<p>It is often useful to know if documents that should have been indexed into a TSDS are rejected, so that they can be further investigated. This blog presents a simple ingest pipeline script that can be used to redirect such documents to a &ldquo;failed&rdquo; index for further investigation.</p>
<h2 id="design">Design<a hidden class="anchor" aria-hidden="true" href="#design">#</a></h2>
<p>In order to ensure that no documents with incorrect timestamps disappear, you may wish to set the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/tsds-index-settings.html">look_ahead_time and look_back_time intervals</a> to a slightly larger time range than what we use in the script presented below. This will ensure that the script catches all timestamp range issues, rather than the indexer failing and the event disappearing. Additionally, if you know that due to ILM running, older indices become read-only, you would want to ensure that the time range defined in the script below would send these documents to a separate index rather than silently failing to write to the read-only index.</p>
<p>Below is a script that gives a general demonstration of the concept of how to redirect events to a different index based on their timestamp. The script should be adjusted so that the time ranges are relevant to your particular situation.</p>
<p>First, lets setup an index template for a data stream as follows:</p>
<pre tabindex="0"><code>
PUT /_index_template/my-data-stream-template?pretty
{
  &#34;index_patterns&#34;: [
    &#34;my-data-stream*&#34;
  ],
  &#34;data_stream&#34;: {},
  &#34;template&#34;: {
    &#34;settings&#34;: {
      &#34;index&#34;: {
        &#34;mode&#34;: &#34;time_series&#34;,
        &#34;routing_path&#34;: [
          &#34;host&#34;
        ],
        &#34;number_of_replicas&#34;: 0,
        &#34;number_of_shards&#34;: 2
      }
    },
    &#34;mappings&#34;: {
      &#34;properties&#34;: {
        &#34;@timestamp&#34;: {
          &#34;type&#34;: &#34;date&#34;
        },
        &#34;bytes&#34;: {
          &#34;type&#34;: &#34;long&#34;,
          &#34;time_series_metric&#34;: &#34;gauge&#34;
        },
        &#34;host&#34;: {
          &#34;type&#34;: &#34;keyword&#34;,
          &#34;time_series_dimension&#34;: true
        }
      }
    }
  }
}
</code></pre><p>You can then define an ingest pipeline that validates time ranges on the incoming events as follows:</p>
<pre tabindex="0"><code>PUT _ingest/pipeline/my-timestamp-pipeline
{
  &#34;description&#34;: &#34;&#34;&#34;If a document falls outside of the time ranges that would result in it being correctly written into a time series data stream, then send it to a special index for further evaluation&#34;&#34;&#34;,
  &#34;processors&#34;: [
    {
      &#34;set&#34;: {
        &#34;field&#34;: &#34;ingest_time&#34;,
        &#34;value&#34;: &#34;{{_ingest.timestamp}}&#34;
      }
    },
    {
      &#34;script&#34;: {
        &#34;lang&#34;: &#34;painless&#34;,
        &#34;source&#34;: &#34;&#34;&#34;
          def future_hours = 2;
          def past_hours = 2;
          
          // Parse the ingest time and original timestamp once
          ZonedDateTime ingestTime = ZonedDateTime.parse(ctx[&#34;ingest_time&#34;]);
          ZonedDateTime eventTimestamp = ZonedDateTime.parse(ctx[&#34;@timestamp&#34;]);
          
          // Check if the original timestamp is more than 2 hours earlier of the ingest time 
          // or more than 2 hours later than the ingest time
          if (eventTimestamp.isBefore(ingestTime.minusHours(past_hours)) || eventTimestamp.isAfter(ingestTime.plusHours(future_hours))) {
            ctx[&#39;_index&#39;] = &#34;timeseries_failures_index&#34;;
          } 
        &#34;&#34;&#34;
      }
    }
    ]
}
</code></pre><p>And finally you can test the above script by passing in documents such as the following (be sure to update the timestamp to fall within a few hours of the current time that you are testing the script):</p>
<pre tabindex="0"><code>PUT /my-data-stream/_bulk?refresh&amp;pipeline=my-timestamp-pipeline&amp;pretty
{&#34;create&#34;: {}}
{&#34;@timestamp&#34;:&#34;2024-04-16T18:11:30Z&#34;,&#34;host&#34;:&#34;host_c&#34;, &#34;bytes&#34;:1234}
{&#34;create&#34;: {}}
{&#34;@timestamp&#34;:&#34;2024-04-16T19:11:30Z&#34;,&#34;host&#34;:&#34;host_c&#34;, &#34;bytes&#34;:2345}
</code></pre><h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>In this article, I have showed how a simple ingest pipeline can be written which will detect documents that have timestamps which would cause them to fail to index in an Elasticsearch Time Series Data Stream (TSDS). This is a proof of concept that can be extended and adapted to your ingest requirements.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/elasticsearch/">Elasticsearch</a></li>
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Alexander Marquardt</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>

<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="light">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Using Logstash and Elasticsearch to calculate transaction duration in a microservices architecture | Alexander Marquardt</title>
<meta name="keywords" content="">
<meta name="description" content="September 16, 2020
Introduction
Elasticsearch  allows you to unify your observability data in a powerful datastore so you can search and apply interactive analytics in real time to a huge number of use cases.
In one such use case, you may be using Elasticsearch to monitor a system that is composed of multiple microservices that process a given transaction. For such a system, you may be collecting an event corresponding to when the first microservice in the system starts processing the transaction, and another event corresponding to when the last microservice in the system finishes processing the transaction. In such an approach, each event should include a field with the transaction identifier, which will allow multiple events corresponding to a single transaction to be combined for analysis.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/using-logstash-and-elasticsearch-scripted-upserts-to-calculate-transaction-duration-from-out-of-order-events/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css" integrity="sha256-NDzEgLn/yPBMy&#43;XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/using-logstash-and-elasticsearch-scripted-upserts-to-calculate-transaction-duration-from-out-of-order-events/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    }

</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Alexander Marquardt (Alt + H)">Alexander Marquardt</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Using Logstash and Elasticsearch to calculate transaction duration in a microservices architecture
    </h1>
    <div class="post-meta"><span title='2020-09-16 00:00:00 +0000 UTC'>September 16, 2020</span>&nbsp;·&nbsp;<span>6 min</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#a-note-about-event-ordering" aria-label="A note about event ordering">A note about event ordering</a></li>
                <li>
                    <a href="#using-scripted-upserts-to-transform-data" aria-label="Using scripted upserts to transform data">Using scripted upserts to transform data</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>September 16, 2020</p>
<h1 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h1>
<p>Elasticsearch  allows you to unify your observability data in a powerful datastore so you can search and apply interactive analytics in real time to a huge number of use cases.</p>
<p>In one such use case, you may be using Elasticsearch to monitor a system that is composed of multiple microservices that process a given transaction. For such a system, you may be collecting an event corresponding to when the first microservice in the system starts processing the transaction, and another event corresponding to when the last microservice in the system finishes processing the transaction. In such an approach, each event should include a field with the transaction identifier, which will allow multiple events corresponding to a single transaction to be combined for analysis.</p>
<p>In this blog I discuss how Elasticsearch in combination with Logstash may be used to ingest multiple events that correspond to a given transaction as it is processed by multiple microservices, and how to calculate the time difference between these different events, which I will refer to as the &ldquo;transaction duration&rdquo;.</p>
<p>The approach discussed here will work even if the events corresponding to a given transaction arrive to Logstash out-of-order, and it could be easily extended to compute delays between any microservices that process a given transaction.</p>
<h1 id="a-note-about-event-ordering">A note about event ordering<a hidden class="anchor" aria-hidden="true" href="#a-note-about-event-ordering">#</a></h1>
<p>If the events corresponding to a given transaction are guaranteed to arrive in order, then it may be possible to use <a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-elapsed.html">Logstash&rsquo;s Elapsed filter plugin</a>.</p>
<p>Alternatively, the approach <em>described in this article</em> should work regardless of the order which events arrive in.</p>
<h1 id="using-scripted-upserts-to-transform-data">Using scripted upserts to transform data<a hidden class="anchor" aria-hidden="true" href="#using-scripted-upserts-to-transform-data">#</a></h1>
<p>In a previous blog post, I described <a href="https://alexmarquardt.com/2019/12/17/logstash-and-elasticsearch-painless-scripted-upserts-transform-data/">how to use Logstash and Elasticsearch scripted upserts to transform data</a>. The approach in this blog is very similar, but has the explicit goal of calculating the duration between the &ldquo;start&rdquo; and &ldquo;end&rdquo; events for a given transaction.</p>
<p>The approach described in this blog will ultimately result in two indices being written into Elasticsearch. One index will contain <em>original</em> documents corresponding to each monitoring event, and another index will contain <em>transformed</em> documents which will track the transaction duration.</p>
<p>For the purposes of this blog, we expect events to contain a &ldquo;@timestamp&rdquo; field, a &ldquo;tags&rdquo; array that contains a value of &ldquo;start_event&rdquo; or &ldquo;end_event&rdquo; somewhere in the array, and a transaction identifier which we have stored in a field called &ldquo;ident&rdquo;. For example, a document could look as follows:</p>
<pre tabindex="0"><code>{
  &#34;message&#34;: &#34;abc&#34;,
  &#34;ident&#34;: &#34;id1&#34;,
  &#34;@timestamp&#34;: &#34;2020-08-18T19:43:36.000Z&#34;,
  &#34;other_field&#34;: &#34;other_val 1&#34;,
  &#34;tags&#34;: [
    &#34;start_event&#34;
  ]
}
</code></pre><p>As we will ultimately be using Logstash to call Elasticsearch scripted upserts to compute the duration of each transaction, it is worth highlighting that Logstash sends the source of each document into the <a href="https://www.elastic.co/guide/en/logstash/7.5/plugins-outputs-elasticsearch.html#plugins-outputs-elasticsearch-scripted_upsert">scripted upsert</a> as <em>params</em>.<em>event</em> rather than in the standard <em>ctx._source</em> that we normally expect.</p>
<p>The following script will calculate the time difference between the &ldquo;start_time&rdquo; and the &ldquo;end_time&rdquo; even if the end event arrives before the start event.</p>
<pre tabindex="0"><code>POST _scripts/calculate_transaction_duration
{
  &#34;script&#34;: {
  &#34;lang&#34;: &#34;painless&#34;,
  &#34;source&#34;: &#34;&#34;&#34;
  

        def position_of_start_event_in_tags = params.event[&#39;tags&#39;].indexOf(&#39;start_event&#39;);

        // if this is a &#34;start event&#34; then store the timestamp in the start_time field
        if (position_of_start_event_in_tags &gt;= 0) {
          ctx._source[&#39;start_time&#39;] = params.event[&#39;@timestamp&#39;]
        }
      
        def position_of_end_event_in_tags = params.event[&#39;tags&#39;].indexOf(&#39;end_event&#39;);

        // if this is a &#34;end event&#34; then store the timestamp in the end_time field
        if (position_of_end_event_in_tags &gt;= 0) {
          ctx._source[&#39;end_time&#39;] = params.event[&#39;@timestamp&#39;]
        }
        
        // if both start and end times exist, calculate the difference 
        if (ctx._source.containsKey(&#39;start_time&#39;) &amp;&amp; ctx._source.containsKey(&#39;end_time&#39;)) {
          ctx._source[&#39;duration_in_seconds&#39;] = ChronoUnit.MILLIS.between(ZonedDateTime.parse(ctx._source[&#39;start_time&#39;]), ZonedDateTime.parse(ctx._source[&#39;end_time&#39;]))/1000;
        }
        // OPTIONAL COPY (PROBABLY NOT NEEDED)  - copy remaining fields into the _source
        //for (x in params.event.entrySet()) {
        //  ctx._source[x.getKey()] = x.getValue();
        //}

    &#34;&#34;&#34;
  }
}
</code></pre><p>We can then test the above script directly from Dev tools by running both of the following commands (in any order) which will update the document with an <em>_id</em> of &ldquo;id1&rdquo; in the <em>test_script</em> index:</p>
<pre tabindex="0"><code>POST test_script/_doc/id1/_update
{
  &#34;scripted_upsert&#34;: true,
  &#34;script&#34;: {
    &#34;id&#34;: &#34;calculate_transaction_duration&#34;,
    &#34;params&#34;: {
      &#34;event&#34;: {
        &#34;message&#34;: &#34;abc&#34;, &#34;ident&#34;: &#34;id1&#34;, &#34;@timestamp&#34;: &#34;2020-08-18T19:43:36.000Z&#34;, &#34;other_field&#34;: &#34;other_val 1&#34;, &#34;tags&#34;: [&#34;start_event&#34;]
      }
    }
  },
  &#34;upsert&#34;: {}
}

POST test_script/_doc/id1/_update
{
  &#34;scripted_upsert&#34;: true,
  &#34;script&#34;: {
    &#34;id&#34;: &#34;calculate_transaction_duration&#34;,
    &#34;params&#34;: {
      &#34;event&#34;: {
        &#34;message&#34;: &#34;def&#34;, &#34;ident&#34;: &#34;id1&#34;, &#34;@timestamp&#34;: &#34;2020-08-18T19:53:36.000Z&#34;, &#34;other_field&#34;: &#34;other_val 2&#34;, &#34;tags&#34;: [&#34;end_event&#34;]
      }
    }
  },
  &#34;upsert&#34;: {}
}
</code></pre><p>After running the above code, we can view the document that contains the transaction duration as follows:</p>
<pre tabindex="0"><code>GET test_script/_doc/id1
</code></pre><p>Which will respond with the following:</p>
<pre tabindex="0"><code> {
  &#34;_index&#34; : &#34;test_script&#34;,
  &#34;_type&#34; : &#34;_doc&#34;,
  &#34;_id&#34; : &#34;id1&#34;,
  &#34;_version&#34; : 2,
  &#34;_seq_no&#34; : 4,
  &#34;_primary_term&#34; : 3,
  &#34;found&#34; : true,
  &#34;_source&#34; : {
    &#34;start_time&#34; : &#34;2020-08-18T19:43:36.000Z&#34;,
    &#34;end_time&#34; : &#34;2020-08-18T19:53:36.000Z&#34;,
    &#34;duration_in_seconds&#34; : 600
  }
}
</code></pre><p>We now have scripted upserts working and tested within Elasticsearch. Now let&rsquo;s get this working from Logstash.</p>
<p>The following Logstash pipeline will send two transactions each with two events into Elasticsearch. Notice that the last two events corresponding to the transaction &ldquo;id2&rdquo; are out-of-order. This is no issue, as the script that we demonstrated above will handle this correctly.</p>
<pre tabindex="0"><code>input {
  # The generator creates input events.
  # Notice how the events associated with id2 are &#34;out of order&#34;
  generator {
    lines =&gt; [
     &#39;{&#34;message&#34;: &#34;abc&#34;, &#34;ident&#34;: &#34;id1&#34;, &#34;@timestamp&#34;: &#34;2020-08-18T19:43:36.000Z&#34;, &#34;other_field&#34;: &#34;other_val 1&#34;, &#34;tags&#34;: [&#34;start_event&#34;]}&#39;,
     &#39;{&#34;message&#34;: &#34;def&#34;, &#34;ident&#34;: &#34;id1&#34;, &#34;@timestamp&#34;: &#34;2020-08-18T19:53:36.000Z&#34;, &#34;other_field&#34;: &#34;other_val 2&#34;, &#34;tags&#34;: [&#34;end_event&#34;]}&#39;,
     &#39;{&#34;message&#34;: &#34;ghi&#34;, &#34;ident&#34;: &#34;id2&#34;, &#34;@timestamp&#34;: &#34;2020-08-20T19:43:56.000Z&#34;, &#34;other_field&#34;: &#34;other_val 4&#34;, &#34;tags&#34;: [&#34;end_event&#34;]}&#39;,
     &#39;{&#34;message&#34;: &#34;jkl&#34;, &#34;ident&#34;: &#34;id2&#34;, &#34;@timestamp&#34;: &#34;2020-08-20T19:43:36.000Z&#34;, &#34;other_field&#34;: &#34;other_val 3&#34;, &#34;tags&#34;: [&#34;start_event&#34;]}&#39;
    ]
    count =&gt; 1
    codec =&gt;  &#34;json&#34;
  }
}
filter {}
output {

  # Transformed data
  elasticsearch {
    index =&gt; &#34;transaction_duration&#34;
    document_id =&gt; &#34;%{ident}&#34;
    action =&gt; &#34;update&#34;
    scripted_upsert =&gt; true
    script_lang =&gt; &#34;&#34;
    script_type =&gt; &#34;indexed&#34;
    script =&gt; &#34;calculate_transaction_duration&#34;
  }

  # Original data
  elasticsearch {
    index =&gt; &#34;transaction_original&#34;
  }
}
</code></pre><p>The above pipeline can be saved into a file called <em>scripted-elapsed.conf</em> and directly executed as follows:</p>
<pre tabindex="0"><code>/bin/logstash -f scripted-elapsed.conf --config.reload.automatic
</code></pre><p>After running the above Logstash pipeline, there will be two indices created in the locally running Elasticsearch. One is the index that contains the original events and is called &ldquo;transaction_original&rdquo;, and the other is the <em>transformed</em> index called &ldquo;transaction_duration&rdquo; that contains the duration of each transaction.</p>
<p>We can look at the &ldquo;transaction_duration&rdquo; index with the following command:</p>
<pre tabindex="0"><code>GET transaction_duration/_search
</code></pre><p>Which will respond with the following two documents which correspond to each transaction:</p>
<pre tabindex="0"><code>    &#34;hits&#34; : [
      {
        &#34;_index&#34; : &#34;transaction_duration&#34;,
        &#34;_type&#34; : &#34;_doc&#34;,
        &#34;_id&#34; : &#34;id2&#34;,
        &#34;_score&#34; : 1.0,
        &#34;_source&#34; : {
          &#34;end_time&#34; : &#34;2020-08-20T19:43:56.000Z&#34;,
          &#34;start_time&#34; : &#34;2020-08-20T19:43:36.000Z&#34;,
          &#34;duration_in_seconds&#34; : 20
        }
      },
      {
        &#34;_index&#34; : &#34;transaction_duration&#34;,
        &#34;_type&#34; : &#34;_doc&#34;,
        &#34;_id&#34; : &#34;id1&#34;,
        &#34;_score&#34; : 1.0,
        &#34;_source&#34; : {
          &#34;end_time&#34; : &#34;2020-08-18T19:53:36.000Z&#34;,
          &#34;start_time&#34; : &#34;2020-08-18T19:43:36.000Z&#34;,
          &#34;duration_in_seconds&#34; : 600
        }
      }
    ]
</code></pre><p>We have now verified that the script to calculate event duration is functioning correctly when we call it from Logstash!</p>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>In this blog post, I first discussed how a given transaction may result in multiple events being sent into Elasticsearch. I then showed how you can use Logstash to execute scripted upserts which calculate the duration of a given transaction by comparing the timestamps of the related events.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/elasticsearch-too-many-script-compilations/">
    <span class="title">« Prev</span>
    <br>
    <span>Understanding and fixing &#34;too many script compilations&#34; errors in Elasticsearch</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/storing-ingest-time-and-calculating-ingest-lag-in-elasticsearch/">
    <span class="title">Next »</span>
    <br>
    <span>Storing ingest time and calculating ingest lag in Elasticsearch</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Alexander Marquardt</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
